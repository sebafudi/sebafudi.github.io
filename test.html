<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Comprehensive Quiz App</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .question {
        margin-bottom: 20px;
      }
      .options {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      button {
        padding: 10px;
        cursor: pointer;
      }
      .feedback {
        margin-top: 10px;
        font-weight: bold;
      }
      .correct {
        color: green;
      }
      .incorrect {
        color: red;
      }
      #score {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: #f0f0f0;
        padding: 10px;
        border-radius: 5px;
      }
      textarea {
        width: 100%;
        height: 100px;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div id="score">
      Score: <span id="correct-count">0</span>/<span id="total-count">0</span>
    </div>
    <div id="quiz-container"></div>
    <button id="next-btn" style="display: none">Next Question</button>

    <script>
      const quizData = {
        questions: [
          {
            type: 'open',
            question:
              'Dlaczego mapujemy encje do transfer obiektów (TO, DTO)? Czym może grozić wysłanie encji przez REST API do klienta webowego? Jaki ma to związek z fetchType = LAZY/EAGER?',
            sample_answer:
              'Mapowanie encji do DTO pozwala na kontrolę przesyłanych danych, unikanie problemów z lazy loading, i zwiększenie bezpieczeństwa. Wysłanie encji przez REST API może prowadzić do wycieków danych i problemów wydajnościowych. FetchType LAZY może powodować błędy przy serializacji, jeśli sesja Hibernate jest już zamknięta.',
          },
          {
            type: 'multiple',
            question: 'Kiedy dane w transakcji zapisywane są do bazy?',
            correct_answer: 'Na końcu transakcji',
            incorrect_answers: [
              'W momencie wywołania flusha',
              'W momencie wywołania metody update/save/persist',
              'W osobnym rollbacku',
            ],
          },
          {
            type: 'open',
            question:
              'Wyjaśnij różnicę między wątkami (thread) a transakcjami (transaction) i jakie warunki dla transakcji muszą być spełnione aby sprawdzić kontrolę równoległego dostępu do danych w bazie.',
            sample_answer:
              'Wątki to jednostki wykonawcze w programie, podczas gdy transakcje to logiczne jednostki pracy w bazie danych. Dla kontroli równoległego dostępu, transakcje muszą być atomowe, spójne, izolowane i trwałe (ACID).',
          },
          {
            type: 'multiple',
            question:
              'Encja została pobrana z bazy i przesłana przez REST API do aplikacji webowej. Przed wysłaniem danych transakcja została zakończona. W jakim stanie znajduje się encja w momencie wysyłania przez REST API?',
            correct_answer: 'Detached',
            incorrect_answers: ['Removed', 'Persisted', 'Transient'],
          },
          {
            type: 'open',
            question:
              'Jak zapisywane są wartości Enum w przypadku użycia adnotacji @Enumerated z następującymi parametrami: a) EnumType.STRING, b) EnumType.ORDINAL, c) brak parametru adnotacji?',
            sample_answer:
              'a) EnumType.STRING - zapisywane jako string, b) EnumType.ORDINAL - zapisywane jako liczba porządkowa, c) brak parametru - domyślnie jako EnumType.ORDINAL.',
          },
          {
            type: 'multiple',
            question:
              'Które adnotacje są niezbędne aby Hibernate mógł powiązać klasę z tabelą (lub stworzyć nową, w zależności od konfiguracji)?',
            correct_answer: '@Entity',
            incorrect_answers: ['@Column', '@Table', '@Id'],
          },
          {
            type: 'multiple',
            question:
              'W bazie danych zdefiniowano relację jeden do wielu między tabelami REZERWACJA i KLIENT. Która z poniższych relacji w Hibernate odpowiada rzeczywistej relacji w bazie danych?',
            correct_answer:
              'rzeczywista - ManyToOne od strony KLIENT, poprawna - OneToMany od strony REZERWACJA',
            incorrect_answers: [
              'rzeczywista - ManyToOne od strony KLIENT, sztuczna - OneToMany od strony REZERWACJA',
              'rzeczywista - OneToMany od strony KLIENT, sztuczna - ManyToOne od strony REZERWACJA',
              'rzeczywista - OneToMany od strony KLIENT, poprawna - ManyToOne od strony REZERWACJA',
            ],
          },
          {
            type: 'open',
            question:
              'Jaki mechanizm uniemożliwia nadpisanie zmian przy równoległej edycji tych samych danych? Na czym polega implementacja w JPA?',
            sample_answer:
              'Mechanizm optymistycznego blokowania (Optimistic Locking). W JPA implementuje się go najczęściej za pomocą adnotacji @Version na polu encji, które automatycznie inkrementuje się przy każdej aktualizacji.',
          },
          {
            type: 'multiple',
            question: 'Co NIE należy do zadań entity managera (EntityManager)?',
            correct_answer: 'Tworzenie połączenia z bazą danych',
            incorrect_answers: [
              'Zapewnienie generycznych metod CRUDowych',
              'Wspomaganie zarządzania transakcją (np. flush, clear)',
              'Tworzenie zapytań JPQL',
            ],
          },
          {
            type: 'open',
            question:
              'Wyjaśnij, czym jest Spring Controller i jaką rolę pełni w architekturze aplikacji opartej na Spring Framework.',
            sample_answer:
              'Spring Controller to komponent odpowiedzialny za obsługę żądań HTTP w aplikacji Spring. Pełni rolę pośrednika między warstwą prezentacji a logiką biznesową, przetwarzając żądania, wywołując odpowiednie serwisy i zwracając odpowiedzi.',
          },
          {
            type: 'multiple',
            question:
              'Które z poniższych stwierdzeń dotyczących konfiguracji aplikacji w Spring Boot jest prawdziwe?',
            correct_answer:
              'Właściwości aplikacji mogą być określone w pliku application.properties, pliku application.yaml lub jako przełączniki wiersza poleceń',
            incorrect_answers: [
              'Właściwości aplikacji mogą być określone tylko w pliku application.yaml',
              'Spring Boot nie obsługuje plików konfiguracyjnych application.properties ani application.yaml',
              'Właściwości aplikacji mogą być określone tylko jako przełączniki wiersza poleceń',
            ],
          },
          {
            type: 'open',
            question:
              'Jak działa mechanizm Dependency Injection (DI)? Podaj przykłady wykorzystania w projekcie realizowanego w ramach laboratorium.',
            sample_answer:
              'Dependency Injection to wzorzec projektowy, w którym zależności obiektu są dostarczane z zewnątrz, a nie tworzone wewnątrz obiektu. W Spring, DI realizuje się najczęściej przez konstruktor, settery lub adnotacje. Przykład: wstrzykiwanie repozytorium do serwisu za pomocą konstruktora lub adnotacji @Autowired.',
          },
          {
            type: 'multiple',
            question:
              'Która z poniższych odpowiedzi dotyczących adnotacji @Async w Spring jest prawidłowa?',
            correct_answer:
              'Adnotacja @Async w Spring pozwala na oznaczenie metod, które powinny być wykonywane asynchronicznie.',
            incorrect_answers: [
              'Adnotacja @Async może być używana tylko na poziomie klasy, a nie na poziomie metody.',
              'Spring Async automatycznie zarządza transakcjami dla asynchronicznych metod, zapewniając spójność danych.',
              'Spring Async jest dostępny tylko dla aplikacji napisanych w języku Groovy.',
            ],
          },
          {
            type: 'multiple',
            question:
              'Które z poniższych stwierdzeń jest prawdziwe dla mechanizmu Spring Event?',
            correct_answer: 'Spring Event jest częścią modułu Spring Context.',
            incorrect_answers: [
              'Aby poprawnie działać, mechanizm Spring Event nie wymaga tworzenia Eventu, Publishera i Listenera.',
              'Rozpoczęcie pracy z mechanizmem Spring Event wymaga konfiguracji.',
              'Spring Event nie zapewnia wsparcia dla mechanizmu wywoływania/obsługi zdarzeń.',
            ],
          },
          {
            type: 'multiple',
            question:
              'Na podstawie kodu z MyService, które ze stwierdzeń jest prawdziwe?',
            correct_answer: 'Kod się nie skompiluje.',
            incorrect_answers: [
              'Klasa MyRepository powinna zostać oznaczona adnotacją @Component',
              'Kod się skompiluje, aplikacja będzie działać poprawnie.',
              'Brakuje adnotacji @InjectBean nad adnotacją @Service',
            ],
          },
          {
            type: 'multiple',
            question:
              'Która z poniższych adnotacji w Springu służy do oznaczenia klas odpowiedzialnych za przetwarzanie żądań HTTP?',
            correct_answer: '@RestController',
            incorrect_answers: ['@Repository', '@Service', '@Rest'],
          },
          {
            type: 'multiple',
            question: 'Która z poniższych funkcji NIE jest cechą Spring Boot?',
            correct_answer:
              'Wymaga manualnej konfiguracji wszystkich komponentów przed uruchomieniem aplikacji',
            incorrect_answers: [
              'Umożliwia szybkie tworzenie aplikacji gotowych do szybkiego uruchomienia z wykorzystaniem Springa',
              'Posiada wbudowany serwer i inne niezbędne komponenty',
              'Automatyczna konfiguracja - do uruchomienia zasadniczej aplikacji nie jest wymagana żadna dodatkowa konfiguracja',
            ],
          },
        ],
      };

      let currentQuestionIndex =
        parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
      let correctCount = parseInt(localStorage.getItem('correctCount')) || 0;
      let totalCount = parseInt(localStorage.getItem('totalCount')) || 0;
      const quizContainer = document.getElementById('quiz-container');
      const nextButton = document.getElementById('next-btn');
      const scoreElement = document.getElementById('score');
      const correctCountElement = document.getElementById('correct-count');
      const totalCountElement = document.getElementById('total-count');
      const answerMap = new Map(
        JSON.parse(localStorage.getItem('answerMap')) || []
      );

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function displayQuestion() {
        if (currentQuestionIndex >= quizData.questions.length) {
          showSummary();
          return;
        }

        const question = quizData.questions[currentQuestionIndex];
        let questionHTML = `
                  <div class="question">
                    <h2>${question.question}</h2>
                `;

        if (question.type === 'multiple') {
          const allAnswers = [
            question.correct_answer,
            ...question.incorrect_answers,
          ];
          const shuffledAnswers = shuffleArray(allAnswers);
          questionHTML += `
                    <div class="options">
                      ${shuffledAnswers
                        .map(
                          (answer) => `
                        <button onclick="checkAnswer('${answer}')">${answer}</button>
                      `
                        )
                        .join('')}
                    </div>
                  `;
        } else if (question.type === 'true_false') {
          questionHTML += `
                    <div class="options">
                      <button onclick="checkAnswer('True')">True</button>
                      <button onclick="checkAnswer('False')">False</button>
                    </div>
                  `;
        } else if (question.type === 'open') {
          questionHTML += `
                    <textarea id="open-answer"></textarea><br>
                    <button onclick="submitOpenAnswer()">Submit</button>
                  `;
        }

        questionHTML += `
                  <div class="feedback"></div>
                </div>
                `;

        quizContainer.innerHTML = questionHTML;
        nextButton.style.display = 'none';
        updateScore();
      }

      function checkAnswer(selectedAnswer) {
        const question = quizData.questions[currentQuestionIndex];
        const feedbackElement = document.querySelector('.feedback');
        const buttons = document.querySelectorAll('.options button');

        buttons.forEach((button) => (button.disabled = true));

        if (selectedAnswer === question.correct_answer) {
          feedbackElement.textContent = 'Correct!';
          feedbackElement.className = 'feedback correct';
          correctCount++;
          answerMap.set(currentQuestionIndex, true);
        } else {
          feedbackElement.textContent = `Incorrect. The correct answer is: ${question.correct_answer}`;
          feedbackElement.className = 'feedback incorrect';
          answerMap.set(currentQuestionIndex, false);
        }

        totalCount++;
        updateScore();
        nextButton.style.display = 'block';
        saveProgress();
      }

      function submitOpenAnswer() {
        const answer = document.getElementById('open-answer').value;
        const question = quizData.questions[currentQuestionIndex];
        const feedbackElement = document.querySelector('.feedback');

        answerMap.set(currentQuestionIndex, answer);

        feedbackElement.innerHTML = `
          <p><strong>Your answer:</strong> ${answer}</p>
          <p><strong>Sample answer:</strong> ${question.sample_answer}</p>
        `;
        feedbackElement.style.display = 'block';

        nextButton.style.display = 'block';
        saveProgress();
      }

      function updateScore() {
        correctCountElement.textContent = correctCount;
        totalCountElement.textContent = totalCount;
      }

      function showSummary() {
        let summaryHTML = '<h2>Quiz Summary</h2>';
        summaryHTML += `<p>Final Score: ${correctCount}/${totalCount}</p>`;
        summaryHTML += '<h3>Questions:</h3>';

        quizData.questions.forEach((question, index) => {
          const answer = answerMap.get(index);
          summaryHTML += `
            <p>
              <strong>Q${index + 1}:</strong> ${question.question}<br>
          `;

          if (question.type === 'open') {
            summaryHTML += `
              <strong>Your Answer:</strong> ${answer}<br>
              <strong>Sample Answer:</strong> ${question.sample_answer}
            `;
          } else {
            summaryHTML += `
              <span class="${answer === true ? 'correct' : 'incorrect'}">
                ${answer === true ? 'Correct' : 'Incorrect'}
              </span><br>
              <strong>Correct Answer:</strong> ${question.correct_answer}
            `;
          }

          summaryHTML += `</p>`;
        });

        quizContainer.innerHTML = summaryHTML;
        nextButton.style.display = 'none';
        scoreElement.style.display = 'none';
        resetProgress();
      }

      function saveProgress() {
        localStorage.setItem('currentQuestionIndex', currentQuestionIndex);
        localStorage.setItem('correctCount', correctCount);
        localStorage.setItem('totalCount', totalCount);
        localStorage.setItem('answerMap', JSON.stringify([...answerMap]));
      }

      function resetProgress() {
        localStorage.removeItem('currentQuestionIndex');
        localStorage.removeItem('correctCount');
        localStorage.removeItem('totalCount');
        localStorage.removeItem('answerMap');
      }

      nextButton.addEventListener('click', () => {
        currentQuestionIndex++;
        saveProgress();
        if (currentQuestionIndex < quizData.questions.length) {
          displayQuestion();
        } else {
          showSummary();
        }
      });

      displayQuestion();
    </script>
  </body>
</html>
